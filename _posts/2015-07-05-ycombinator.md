---
layout: post
title:  "The applicative Y combinator"
date:   2015-07-05 14:02:50
categories: [functional, y-combinator]
tags:
  - functional-programming
  - combinators
---

In the [untyped lambda calculus][wiki-lambda], you cannot assign names to functions,
you just have the possibility to define anonymous functions.
This is a puzzle: in such an environment, how can you define recursive functions? Y is a fundamental (and nice) theoretical exercise.

These are my notes based on chapter 9 of [The Little Schemer][little-schemer].
Buy it, it's a great book.

I develop the applicative Y combinator from the function
`factorial`.
The code is in Clojure, which has a limited [TCO][tail-call].
Thus, don't use the factorial defined here, it will break your stack.


I suggest to run this stuff in a Clojure REPL. The [Lighttable][lighttable] Instant REPL is perfect to experiment!
In [This post][clojure-intro] you can find some notes on how to setup everything.

The first section contains the basic transformation I perform
during the post. In the second section I define an anonymous function computing the factorial. In the last one, I perform some cleanup, and I finally extract the factorial function and the applicative Y combinator.

## How to create bindings

Consider

{% highlight clojure linenos=table %}
(fn [n] (+ n 1))
{% endhighlight %}

If we have just anonymous functions, how can we bind this to the name `increment` ?.

We can simply create a new anonymous function, which takes `increment` as parameter,
and we pass the anonymous function  above as argument.

{% highlight clojure linenos=table %}
((fn [increment]   ; the "environment"
  (println "The name increment exists. (increment 1) is" (increment 1)))
(fn [n] (+ n 1))) ; the argument
{% endhighlight %}

If executed, it will print `The name increment exists. (increment 1) is 2`

This is the primitive transformation used throughout this post.

## Factorial

In this section we are going to build an anonymous function
which computes the factorial using recursion.

Since I need a placeholder pointing to the location where I should recur, I define this helper

{% highlight clojure linenos=table %}
(defn if-only-i-could-recur [x] (throw (Exception. "you cannot call me")))
{% endhighlight %}

I couldn't, since I cannot name things, but it's just a placeholder. If invoked, it will raise an Exception.

The `factorial` function looks like this template

{% highlight clojure linenos=table %}
(fn [n]
  (cond
   (zero? n) 1
   :else (* n
            (if-only-i-could-recur (dec n)))))
{% endhighlight %}

It takes an integer as parameter:
1.  if it's 0, then the factorial is 1
2.  otherwise we should the factorial itself on n-1. Unfortunately we can't, because we don't have a name to refer to itself.

This functional is just able to compute the factorial of 0.
How can we assign a name to the next recursive steps? By wrapping all in a new function.

{% highlight clojure linenos=table %}
((fn [recursive-step]
  (fn [n]
    (cond
     (zero? n) 1
     :else (* n
              (recursive-step (dec n))))))
 if-only-i-could-recur)
{% endhighlight %}

This is really the same of the above, it can just compute the factorial of 0.

As a refactoring, I want to give a name to the template of the factorial function. Again, I create an anonymous function to name it  `build-factorial`.

{% highlight clojure linenos=table %}
((fn [build-factorial]
   (build-factorial if-only-i-could-recur))
 (fn [recursive-step]
  (fn [n]
    (cond
     (zero? n) 1
     :else (* n
              (recursive-step (dec n)))))))
{% endhighlight %}

How can I make it perform more steps? Instead of `if-only-i-could-recur`, the recursive step should be  the function generated by `build-factorial`, i.e. the template of
the factorial function.

To start, we can use simply `build-factorial`.

{% highlight clojure linenos=table %}
((fn [build-factorial]
   (build-factorial build-factorial))
 (fn [recursive-step]
  (fn [n]
    (cond
     (zero? n) 1
     :else (* n
              (recursive-step
               (dec n)))))))
{% endhighlight %}

but unfortunately this function is broken. Try to run it!

The problem is that at line 8 we call `recursive-step`, which
now is bounded to `build-factorial`. But `build-factorial` is *not* the factorial function, it builds it when receive a function (the recurring step) as argument.
Which function can we give to it as a parameter. *The key is that the only function with a name here is `recursive-step` itself.
So we use it.*

{% highlight clojure linenos=table %}
((fn [build-factorial]
   (build-factorial build-factorial))
 (fn [recursive-step]
  (fn [n]
    (cond
     (zero? n) 1
     :else (* n
              ((recursive-step recursive-step)
               (dec n)))))))
{% endhighlight %}

This is a working factorial definition. Try it!

## Extract Y
The goal is now to refactor the last expression we wrote to extract the factorial function. The remaining part will be Y.

First of all, we are going to extract the  `(recursive-step recursive-step)` call at line 8.
That is a function that receives an argument, and apply   `(recursive-step recursive-step)` to it. In Clojure this is

{% highlight clojure linenos=table %}
(fn [x] ((recursive-step recursive-step) x))
{% endhighlight %}

which means, in our factorial function

{% highlight clojure linenos=table %}
((fn [build-factorial]
  (build-factorial build-factorial))
(fn [recursive-step]
 (fn [n]
   (cond
    (zero? n) 1
    :else (* n
             ((fn [x] ((recursive-step recursive-step) x))
             (dec n)))
   ))
 ))
{% endhighlight %}

Now I want to extract that, assigning a name to it. Which name? Since that's the place for the recursive call, it seems natural to call it `factoral`.

{% highlight clojure linenos=table %}
((fn [build-factorial]
  (build-factorial build-factorial))
(fn [recursive-step]
  ((fn [factorial]
    (fn [n]
      (cond
       (zero? n) 1
       :else (* n
             (factorial
             (dec n))))))
   (fn [x] ((recursive-step recursive-step) x)))))
{% endhighlight %}

Now what's beneath `((fn [factorial]...` really looks like the recursive definition of factorial.
  I name it `f` and I extract it to get

  {% highlight clojure linenos=table %}
  ((fn [f]
     ((fn [build-factorial]
        (build-factorial build-factorial))
      (fn [recursive-step]
        (f
         (fn [x] ((recursive-step recursive-step) x))))))
   (fn [factorial]
     (fn [n]
       (cond
        (zero? n) 1
        :else (* n
                 (factorial
                  (dec n)))))))
  {% endhighlight %}

Here the anonymous function `(fn [factorial] ...)` returns
a function whose body is the form `(fn [n] ...)`, which computes the factorial of `n` by calling `factorial` to recur.

It works because it is passed as argument to another function,  
  which calls it by passing as argument (which is the recursive step) a new instance of `(fn [n] ...)`. We call this function Y.

  {% highlight clojure linenos=table %}
  (defn Y
    [f]
    ((fn [g] (g g))
     (fn [h]
       (f
        (fn [x] ((h h) x))))))
  {% endhighlight %}

  In an environment where you cannot name things, Y allows you to build functions referring to themselves.

{% highlight clojure linenos=table %}
  (Y
  (fn [factorial]
    (fn [n]
      (cond
       (zero? n) 1
       :else (* n
                (factorial
                 (dec n)))))))
 {% endhighlight %}

 returns the factorial function.

 {% highlight clojure linenos=table %}
 ((Y
  (fn [factorial]
    (fn [n]
      (cond
       (zero? n) 1
       :else (* n
                (factorial
                 (dec n)))))))
 5)
{% endhighlight %}

is 120.

[wiki-lambda]:  https://en.wikipedia.org/wiki/Lambda_calculus
[little-schemer]: https://mitpress.mit.edu/books/little-schemer
[tail-call]:  https://en.wikipedia.org/wiki/Tail_call
[lighttable]: http://lighttable.com/
[clojure-intro]: /clojure/intro
